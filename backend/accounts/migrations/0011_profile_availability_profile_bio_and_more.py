# Generated by Django 5.2.8 on 2025-11-16 00:41

import django.contrib.postgres.indexes
import uuid
from django.db import migrations, models


PROFILE_FIELD_SPECS = [
    (
        "availability",
        models.CharField,
        {
            "blank": True,
            "choices": [
                ("full_time", "Full-time"),
                ("part_time", "Part-time"),
                ("project", "Project-based"),
            ],
            "max_length": 20,
        },
    ),
    ("bio", models.TextField, {"blank": True}),
    (
        "contact_pref",
        models.CharField,
        {
            "choices": [
                ("platform", "Platform"),
                ("email", "Email"),
                ("phone", "Phone"),
            ],
            "default": "platform",
            "max_length": 20,
        },
    ),
    ("headline", models.CharField, {"blank": True, "max_length": 255}),
    (
        "hourly_rate",
        models.DecimalField,
        {
            "blank": True,
            "decimal_places": 2,
            "max_digits": 10,
            "null": True,
        },
    ),
    ("languages", models.JSONField, {"blank": True, "default": list}),
    (
        "last_activity_at",
        models.DateTimeField,
        {"blank": True, "null": True},
    ),
    ("links", models.JSONField, {"blank": True, "default": list}),
    ("location", models.JSONField, {"blank": True, "default": dict}),
    (
        "min_budget",
        models.DecimalField,
        {
            "blank": True,
            "decimal_places": 2,
            "max_digits": 12,
            "null": True,
        },
    ),
    (
        "slug",
        models.SlugField,
        {
            "blank": True,
            "db_index": False,
            "max_length": 160,
            "null": True,
        },
    ),
    ("timezone", models.CharField, {"blank": True, "max_length": 64}),
    (
        "visibility",
        models.CharField,
        {
            "choices": [
                ("public", "Public"),
                ("private", "Private"),
                ("link_only", "Link-only"),
            ],
            "default": "public",
            "max_length": 20,
        },
    ),
]


def build_profile_fields():
    return [
        (name, field_class(**field_kwargs))
        for name, field_class, field_kwargs in PROFILE_FIELD_SPECS
    ]


def profile_table_has_column(schema_editor, column_name):
    with schema_editor.connection.cursor() as cursor:
        cursor.execute(
            """
            SELECT 1
            FROM information_schema.columns
            WHERE table_name = %s
              AND table_schema = current_schema()
              AND column_name = %s
            LIMIT 1
            """,
            ["accounts_profile", column_name],
        )
        return cursor.fetchone() is not None


def ensure_profile_field_if_missing(apps, schema_editor, field_name, field):
    if profile_table_has_column(schema_editor, field_name):
        return

    profile_model = apps.get_model("accounts", "Profile")
    field.set_attributes_from_name(field_name)
    schema_editor.add_field(profile_model, field)


def ensure_profile_fields(apps, schema_editor):
    for name, field in build_profile_fields():
        ensure_profile_field_if_missing(apps, schema_editor, name, field)


PROFILE_FIELD_STATE_OPERATIONS = [
    migrations.AddField(
        model_name="profile",
        name=name,
        field=field,
    )
    for name, field in build_profile_fields()
]


def drop_legacy_profile_slug_index(apps, schema_editor):
    """Drop the legacy LIKE index that may linger on older databases."""

    if schema_editor.connection.vendor != "postgresql":  # pragma: no cover - safety
        return

    index_name = "accounts_profile_slug_8a7a322e_like"
    with schema_editor.connection.cursor() as cursor:
        cursor.execute(
            """
            SELECT n.nspname
            FROM pg_class c
            JOIN pg_namespace n ON n.oid = c.relnamespace
            WHERE c.relkind = 'i' AND c.relname = %s
            """,
            [index_name],
        )
        schemas = [row[0] for row in cursor.fetchall()]

        # Drop the index for every schema it may exist in. Afterwards, perform a
        # final drop without the schema qualifier as a best-effort fallback so
        # we cover databases that rely on the current search path.
        quote = schema_editor.quote_name
        for schema in schemas:
            cursor.execute(
                f"DROP INDEX IF EXISTS {quote(schema)}.{quote(index_name)} CASCADE"
            )

        cursor.execute(
            f"DROP INDEX IF EXISTS {quote(index_name)} CASCADE"
        )


def drop_legacy_profile_slug_unique_constraint(apps, schema_editor):
    """Drop leftover unique constraints from early slugs."""

    if schema_editor.connection.vendor != "postgresql":  # pragma: no cover - safety
        return

    constraint_name = "accounts_profile_slug_8a7a322e_uniq"
    with schema_editor.connection.cursor() as cursor:
        cursor.execute(
            """
            SELECT n.nspname
            FROM pg_constraint c
            JOIN pg_class t ON t.oid = c.conrelid
            JOIN pg_namespace n ON n.oid = t.relnamespace
            WHERE c.conname = %s AND t.relname = %s
            """
            ,
            [constraint_name, "accounts_profile"],
        )

        schemas = [row[0] for row in cursor.fetchall()]
        quote = schema_editor.quote_name

        for schema in schemas:
            cursor.execute(
                f"ALTER TABLE {quote(schema)}.{quote('accounts_profile')} DROP CONSTRAINT IF EXISTS {quote(constraint_name)} CASCADE"
            )

        cursor.execute(
            f"ALTER TABLE {quote('accounts_profile')} DROP CONSTRAINT IF EXISTS {quote(constraint_name)} CASCADE"
        )


def populate_profile_slugs(apps, schema_editor):
    Profile = apps.get_model("accounts", "Profile")

    for profile in Profile.objects.filter(slug__isnull=True).iterator():
        profile.slug = str(uuid.uuid4())
        profile.save(update_fields=["slug"])


class Migration(migrations.Migration):

    dependencies = [
        ("accounts", "0010_delete_notification"),
        ("marketplace", "0005_skillsynonym_category_description_ru_and_more"),
    ]

    # The first operation explicitly drops an index. Running this migration in a
    # non-atomic mode ensures that, once the drop succeeds, PostgreSQL commits
    # it immediately and the subsequent schema changes never see the old index.
    atomic = False

    operations = [
        # In some environments a previous slug field or index may still exist
        # even though the migration history does not contain it. When Django
        # tries to add or alter the slug field it attempts to recreate the
        # accompanying index, which results in PostgreSQL raising a
        # ``DuplicateTable`` error because the index (named
        # ``accounts_profile_slug_8a7a322e_like``) is already present. To keep
        # the migration idempotent we explicitly drop that leftover index if it
        # exists before proceeding with the new field additions.
        migrations.RunPython(
            drop_legacy_profile_slug_index, migrations.RunPython.noop
        ),
        migrations.RunPython(
            drop_legacy_profile_slug_unique_constraint,
            migrations.RunPython.noop,
        ),
        migrations.SeparateDatabaseAndState(
            database_operations=[
                migrations.RunPython(
                    ensure_profile_fields,
                    migrations.RunPython.noop,
                )
            ],
            state_operations=PROFILE_FIELD_STATE_OPERATIONS,
        ),
        migrations.RunPython(populate_profile_slugs, migrations.RunPython.noop),
        migrations.AlterField(
            model_name="profile",
            name="slug",
            field=models.SlugField(
                db_index=False, default=uuid.uuid4, max_length=160, unique=True
            ),
        ),
        migrations.AddIndex(
            model_name="profile",
            index=django.contrib.postgres.indexes.GinIndex(
                fields=["languages"], name="profile_languages_gin"
            ),
        ),
        migrations.AddIndex(
            model_name="profile",
            index=models.Index(
                fields=["hourly_rate", "min_budget"], name="profile_rate_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="profile",
            index=models.Index(
                fields=["is_verified", "visibility"], name="profile_verified_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="profile",
            index=models.Index(
                fields=["last_activity_at"], name="profile_last_activity_idx"
            ),
        ),
        migrations.AddIndex(
            model_name="profile",
            index=models.Index(
                fields=["slug"],
                name="profile_slug_like_idx",
                opclasses=["varchar_pattern_ops"],
            ),
        ),
    ]
