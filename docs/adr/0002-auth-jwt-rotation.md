# ADR 0002: JWT сессии с ротацией refresh-токена

## Статус

Принято — 2024-04-27

## Контекст

Текущая система аутентификации базируется на stateless токенах Django REST Framework (`TokenAuthentication`) без возможности управлять сроком жизни сессии, безопасно отзывать устройства или вводить многофакторную аутентификацию. Для выхода на Stage/Prod требуется более безопасное решение, совместимое с политиками хранения секретов и требующее минимальных изменений клиента.

## Решение

1. **JWT access + refresh.**
   - Access-токен со сроком жизни 5–10 минут (по умолчанию 600 секунд).
   - Refresh-токен со сроком жизни 14–30 дней (по умолчанию 28 дней).
   - Refresh хранится только в `HttpOnly`, `Secure`, `SameSite=Strict` cookie `refresh_token`.
2. **Скользящая ротация refresh.**
   - При каждом обмене refresh-токена выдаём новый refresh с новым `jti`, обновлённым `exp`.
   - Сохраняем «максимальное окно жизни» refresh (по умолчанию 30 дней) и «скользящее окно» (по умолчанию 14 дней). Если refresh использован позже окна, сессия завершается и требуется повторный логин.
3. **Ключи подписи.**
   - Используем асимметричные пары (RSA или EC) с `kid`.
   - Разные ключевые пары для access и refresh токенов и для окружений Dev/Stage/Prod.
   - Пары хранятся в Secret Manager, выдаются приложению через ENV.
4. **Фичефлаги.**
   - `auth.jwt` — включает JWT-аутентификацию и REST endpoints обмена.
   - `auth.token_legacy` — оставляет поддержку старых DRF Token auth.
   - `auth.2fa` — включает требование MFA при логине (внедрим позже).
   - `upload.scanner` — включает проверку загружаемых файлов антивирусом.
   - `admin.hardening` — включает дополнительные проверки безопасности админки.
5. **Отзыв сессий.**
   - «Logout all»: запись `jti`/device в таблицу блокировок, инвалидирует все активные refresh токены пользователя.
   - «Revoke device»: инвалидирует конкретный `jti` и все производные access токены.
   - Access токены не отзываются напрямую, а истекают естественно (≤10 минут); бекенд проверяет `jti` в denylist перед выдачей нового access токена.
6. **Совместимость.**
   - Два фичефлага (`auth.jwt`, `auth.token_legacy`) позволяют постепенно мигрировать клиентов.
   - На Stage запускаем новое решение с «окном совместимости» 2 недели: оба флага включены, логины выдают JWT + legacy токен. После двух недель отключаем legacy.

## Альтернативы

- Оставить только DRF TokenAuth — отклонено из-за отсутствия управления жизненным циклом.
- Использовать opaque session ID + серверное состояние — увеличивает нагрузку и сложность шардирования, отказались.

## Последствия

- Потребуется хранить denylist refresh-токенов и audit trail.
- Появляется необходимость безопасного хранения ключей и процедуры ротации (см. `docs/jwt-key-rotation.md`).
- Клиентам потребуется поддержка cookie при обмене refresh-токенов.
- DevOps обязан следить за актуальностью фичефлагов при деплое и обновлять Secret Manager при ротации ключей.

## План реализации

1. Ввести модуль `jwt_settings.py`, читающий ENV и описывающий политику JWT/refresh cookie.
2. Подготовить REST endpoints для логина/обновления токенов (следующие задачи).
3. Добавить модели хранения refresh с `jti`, историю и denylist.
4. Обновить документацию по переменным окружения и ротации ключей.
5. Настроить monitorинг/алертинг по ошибкам валидации JWT и превышению denylist.

## План отката

- Хранить фичефлаг `auth.token_legacy` включённым на Stage в течение двух недель.
- Для отката к legacy auth достаточно выключить `auth.jwt` и включить `auth.token_legacy`; существующие JWT перестанут обновляться, пользователи перелогинятся по старой схеме.
- В случае критических ошибок удалить refresh cookies (очистка домена) и перевыпустить legacy токены.
