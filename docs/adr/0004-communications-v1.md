# ADR 0004: Communications v1

## Статус
Принято

## Контекст
Команда запускает единый чат между заказчиком и исполнителем, а также поток урегулирования споров. Ключевые требования:

- Чат должен работать в реальном времени, но при этом иметь запасной транспорт на случай отсутствия WebSocket.
- Необходимо гарантировать доставку сообщений, отслеживать их состояния и поддерживать повторные попытки при сетевых сбоях.
- Сообщения чата и споров должны храниться в БД ограниченный период времени с учётом юридических требований (особенно для escrow).
- Интеграция со схемой escrow обязана фиксировать связь сообщений с контрактами и платежами.

## Решение

### Транспорт обмена
- **WebSocket** — основной канал. Один websocket-хаб (`/ws/chat/{conversation_id}/`) обслуживает как прямые чаты, так и ветки споров. Он поддерживает мультиплексирование нескольких диалогов в одном подключении.
- **Server-Sent Events (HTTP/SSE)** — fallback №1. Клиент автоматически переключается на эндпоинт `/api/communications/sse` после 2 неудачных попыток установления WS. Подписка поддерживает передачу только входящих событий.
- **HTTP long polling** — fallback №2. Используется, когда браузер/прокси режет SSE. Тайм-аут одного запроса — 25 секунд.
- Все транспорты используют единый протокол сообщений (JSON envelopes) и общий идентификатор доставки (`message_uuid`).

### Модель доставки
- Состояния сообщений: `sent → delivered → read`.
  - **sent** — сервер принял событие, записал его в таблицу `communications_message` и вернул ack отправителю.
  - **delivered** — получатель установил websocket/SSE/long-poll соединение и подтвердил доставку (`delivery_ack`). Если ack не пришёл за 5 секунд, сервер повторно пушит сообщение (до 3 ретраев) и эскалирует в очередь email/webpush-уведомлений.
  - **read** — получатель отправляет `read_ack` с последним прочитанным `message_uuid`. Сервер обновляет поле `read_at` и пушит событие обеим сторонам.
- Тайм-ауты и ретраи:
  - Повторная отправка `sent` сообщений выполняется каждые 5 секунд, максимум 3 раза. После истечения лимита сообщение помечается как `delivery_failed`, но остаётся доступным в истории.
  - При повторном подключении клиента сервер выполняет `gap sync` (до 200 сообщений) и восстанавливает непрочитанные ack.

### Хранение и схемы данных
- Создаём две модели: `communications_conversation` и `communications_message` (в приложении `marketplace.communications`):
  - `communications_conversation` содержит ссылки на `marketplace.Contract` и необязательный `dispute_id`. Тип (`direct_chat` или `dispute_thread`) определяет бизнес-логику.
  - `communications_message` хранит `conversation`, `sender_profile`, `payload`, `attachment_ref`, `state`, `delivery_attempts`, `sent_at`, `delivered_at`, `read_at`, `retention_expires_at`.
- Для связи с платежами/escrow:
  - Каждое `communications_conversation` хранит `contract_id` (FK) и `escrow_transfer_id` (FK на таблицу `finance.EscrowTransfer`, которая уже привязана к кошелькам/транзакциям).
  - Споры (`dispute_thread`) дополнительно содержат `dispute_case_id` (FK на новую модель `marketplace.DisputeCase`). Внутри спора каждое сообщение может ссылаться на конкретный `escrow_payment_id` или `milestone_id`, чтобы участники и арбитры видели финансовый контекст.

### Политика ретенции
- **Рабочие чаты (direct_chat)**:
  - Активные контракты: храним все сообщения.
  - После перехода контракта в `Contract.STATUS_COMPLETED` или `STATUS_TERMINATED` сохраняем историю 6 месяцев. Затем поля `payload` и `attachment_ref` очищаются, остаются только метаданные (для аудита) ещё на 6 месяцев.
- **Споры (dispute_thread)**:
  - Сообщения доступны до закрытия спора + 24 месяца (юридические требования по эскроу и chargeback).
  - После 24 месяцев данные архивируются во внешнее хранилище (S3 bucket `communications-archive`) и удаляются из основной БД. Метаданные (`message_uuid`, участники, итоговое решение) остаются для аудита.

### Интеграция с escrow
- Каждое сообщение и спор привязаны к конкретному `Contract`, который уже связан с заказом, клиентом и исполнителем.
- При создании спора backend фиксирует `escrow_transfer_id` (депозит контракта) и `wallet_transaction_ids`, чтобы арбитраж видел исходные суммы.
- Когда арбитр оставляет решение в ветке спора, сообщение содержит `resolution_payload` с полями `payout_to_client`, `payout_to_freelancer`, `fee_adjustment`. Эти поля валидируются, чтобы сумма совпадала с текущим балансом escrow.
- Уведомления о действиях с escrow (`funded`, `released`, `disputed`) транслируются как системные сообщения в соответствующий `communications_conversation`.

## Последствия
- Появляется отдельное приложение `communications` с зависимостью от `marketplace` и `accounts`.
- WebSocket-инфраструктура требует sticky-сессий или Redis pub/sub для фан-аута сообщений.
- Нужно добавить фоновые задачи для ретеншн-политики и повторных отправок (`celery` или Django-Q).
- Жёсткая связка с escrow и контрактами упрощает аудит, но усложняет миграции — любые изменения в финансовых моделях требуют синхронного апдейта коммуникаций.
- Новые фичефлаги позволяют пошагово включать чат/споры/нотификации в окружениях Dev → Stage → Prod.

## План внедрения
1. Реализовать модели `communications_conversation`/`communications_message` и миграции.
2. Настроить websocket-шлюз и SSE/long-poll endpoints с единой аутентификацией (JWT + контрактные проверки).
3. Добавить фоновые задачи для повторных попыток доставки и ретенции.
4. Интегрировать escrow/контракты и отобразить коммуникации в UI.
5. Включить фичефлаги на Dev, провести нагрузочные тесты, затем постепенно активировать на Stage и Prod.
